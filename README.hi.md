<p align="center">
  <a href="README.md">English</a> | <a href="README.ja.md">日本語</a> | <a href="README.zh.md">中文</a> | <a href="README.es.md">Español</a> | <a href="README.fr.md">Français</a> | <strong>हिन्दी</strong> | <a href="README.it.md">Italiano</a> | <a href="README.pt-BR.md">Português</a>
</p>

<p align="center">
  <img src="logo.png" alt="mcp-aside लोगो" width="280" />
</p>

<h1 align="center">mcp-aside</h1>

<p align="center">
  एक MCP सर्वर जो आपके AI को बातचीत के बीच में नोट्स लिखने की जगह देता है — बिना मुख्य कार्य को बाधित किए।
</p>

<p align="center">
  <a href="#त्वरित-शुरुआत">त्वरित शुरुआत</a> &middot;
  <a href="#कैसे-काम-करता-है">कैसे काम करता है</a> &middot;
  <a href="#टूल्स">टूल्स</a> &middot;
  <a href="#कॉन्फ़िगरेशन">कॉन्फ़िगरेशन</a> &middot;
  <a href="#लाइसेंस">लाइसेंस</a>
</p>

---

## क्यों

LLM चीज़ें भूल जाते हैं। एक अधूरा विचार, एक आधी-अधूरी चिंता, एक "हमें इस पर वापस आना चाहिए" जो कभी नहीं होता। **mcp-aside** मॉडल को एक समर्पित इनबॉक्स देता है — रेट-लिमिटेड, डिडुप्लिकेटेड, और ऑटो-एक्सपायरिंग ताकि इनबॉक्स खुद एक समस्या न बने।

इसे बातचीत के बगल में रखे स्टिकी नोट्स की तरह समझें। मॉडल नोट्स लिखता है। आप (या मॉडल) उन्हें सही समय पर पढ़ते हैं।

## कैसे काम करता है

1. मॉडल `aside.push` कॉल करता है, प्राथमिकता के साथ एक विचार भेजता है।
2. गार्डरेल डुप्लिकेट, रेट लिमिट और TTL कैप की जांच करते हैं।
3. अगर पास होता है, तो इंटरजेक्शन इन-मेमोरी इनबॉक्स में जाता है।
4. क्लाइंट को `notifications/resources/updated` के माध्यम से सूचित किया जाता है।
5. कोई भी `interject://inbox` रिसोर्स के माध्यम से इनबॉक्स पढ़ सकता है।

कोई डेटाबेस नहीं। कोई परसिस्टेंस नहीं। सर्वर बंद होने पर इनबॉक्स गायब — यह डिज़ाइन के अनुसार है।

## त्वरित शुरुआत

```bash
npm install
npm run build
node build/index.js
```

सर्वर **stdio** पर MCP बोलता है। किसी भी MCP-संगत क्लाइंट को इसकी ओर इंगित करें:

```json
{
  "mcpServers": {
    "aside": {
      "command": "node",
      "args": ["build/index.js"]
    }
  }
}
```

## टूल्स

| टूल | क्या करता है |
|---|---|
| `aside.push` | इनबॉक्स में इंटरजेक्शन भेजें। `text`, `priority` (low/med/high), `reason`, `tags`, `expiresAt`, `source`, और `meta` स्वीकार करता है। |
| `aside.configure` | रनटाइम पर गार्डरेल एडजस्ट करें — TTL कैप, रेट लिमिट, डिडुप विंडो, नोटिफिकेशन थ्रेशोल्ड। |
| `aside.clear` | इनबॉक्स साफ़ करें। |
| `aside.status` | इनबॉक्स साइज़ और वर्तमान गार्डरेल कॉन्फ़िग का रीड-ओनली स्नैपशॉट। |

## रिसोर्स

| URI | विवरण |
|---|---|
| `interject://inbox` | पेंडिंग इंटरजेक्शन का JSON ऐरे, नवीनतम पहले। एक्सपायर्ड आइटम पढ़ते समय फ़िल्टर किए जाते हैं। |

## गार्डरेल

सब कुछ `aside.configure` से कॉन्फ़िगर करने योग्य। डिफ़ॉल्ट:

| सेटिंग | डिफ़ॉल्ट | क्या नियंत्रित करता है |
|---|---|---|
| `defaultTtlSeconds` | 600 (10 मिनट) | स्पष्ट एक्सपायरी न होने पर इंटरजेक्शन कितनी देर जीवित रहता है |
| `maxTtlSeconds` | 3600 (1 घंटा) | TTL की हार्ड कैप, भले ही कॉलर अधिक मांगे |
| `dedupeWindowSeconds` | 300 (5 मिनट) | समान प्राथमिकता + टेक्स्ट + कारण = इस विंडो में दबाया जाता है |
| `rateLimitWindowSeconds` | 60 | रेट लिमिटिंग के लिए स्लाइडिंग विंडो |
| `rateLimitMax` | low: 6, med: 3, high: 1 | प्रति प्राथमिकता प्रति विंडो अधिकतम पुश |
| `notifyAtOrAbove` | high | केवल इस प्राथमिकता या उससे ऊपर के आइटम के लिए लॉग नोटिफिकेशन भेजें |

## कॉन्फ़िगरेशन

### टाइमर ट्रिगर

एक बिल्ट-इन टाइमर हर 5 मिनट में सक्रिय होता है, कम प्राथमिकता का "कोई ब्लॉकर?" चेक-इन भेजता है। यह मैन्युअल पुश के समान गार्डरेल का पालन करता है (इसलिए यह डिडुप या रेट-लिमिट हो सकता है)। `index.ts` में `startTimerTrigger` कॉल को कमेंट करके अक्षम करें।

### MCP इंस्पेक्टर

लोकल टेस्टिंग के लिए:

```
Transport: STDIO
Command:   node
Args:      build/index.js
```

## नोट्स

- लॉग **stderr** पर जाते हैं — stdout MCP JSON-RPC के लिए आरक्षित है।
- इनबॉक्स अस्थायी है। रीस्टार्ट = साफ़ स्लेट।
- इंटरजेक्शन नवीनतम-पहले क्रम में संग्रहीत। एक्सपायर्ड आइटम हर रीड और पुश पर साफ़ किए जाते हैं।

## लाइसेंस

[MIT](LICENSE)
